@using Memorabilia.Application.Features.Image
@using Memorabilia.Domain.Constants
@using Microsoft.AspNetCore.Hosting
@using Microsoft.Extensions.Logging
@using System 
@using System.IO

@inject IWebHostEnvironment _environment
@inject ProtectedLocalStorage _localStorage
@inject ILogger<_ImageFileSelector> _logger
@inject NavigationManager _navigation

<div class="row">
    <InputFile OnChange="@LoadFiles" accept="image/*" multiple @bind-Value="@Value" />
</div>
<div class="row" hidden="@(!DisplayPreview)">
    @foreach(var image in Value)
    {
        <_ImageEditor CanRemove="CanRemove"
                      HasPrimary="HasPrimary"
                      ImageFilePath="@image.FilePath"
                      ImageType="@Domain.Constants.ImageType.Find(image.ImageTypeId)"
                      IsPrimary="@image.IsPrimary"
                      OnPrimarySet="SetPrimary"
                      OnRemove="Remove" />     
    } 
</div>

@code {
    private IReadOnlyList<IBrowserFile> _files;

    [Parameter]
    public bool CanRemove { get; set; }

    [Parameter]
    public bool DisplayPreview { get; set; }

    [Parameter]
    public bool HasPrimary { get; set; }

    [Parameter]
    public int? MaximumAllowedFiles { get; set; }

    [Parameter]
    public long? MaximumFileSize { get; set; }

    [Parameter]
    public EventCallback<string> OnPrimarySet { get; set; }  

    [Parameter]
    public EventCallback<string> OnRemove { get; set; }   

    [Parameter]
    public List<SaveImageViewModel> Value { get; set; } = new();

    [Parameter]
    public EventCallback<List<SaveImageViewModel>> ValueChanged { get; set; }   

    protected async Task Remove(string filePath)
    {
        if (File.Exists(filePath))
            File.Delete(filePath);

        await OnRemove.InvokeAsync(filePath).ConfigureAwait(false);
    }

    protected async Task SetPrimary(string filePath)
    {
        await OnPrimarySet.InvokeAsync(filePath).ConfigureAwait(false);
    }

    private async Task LoadFiles(InputFileChangeEventArgs e)
    {
        var userId = await _localStorage.GetAsync<int>("UserId").ConfigureAwait(false);

        if (userId.Value == 0)
            _navigation.NavigateTo("Login");

        _files = e.GetMultipleFiles(MaximumAllowedFiles ?? 5);

        await Save().ConfigureAwait(false);
    }   

    private async Task Save()
    {
        var userId = await _localStorage.GetAsync<int>("UserId").ConfigureAwait(false);

        if (userId.Value == 0)
            _navigation.NavigateTo("Login");

        var images = new List<SaveImageViewModel>();
        var imageType = Domain.Constants.ImageType.Primary;

        foreach (var file in _files)
        {
            try
            {
                var directory = Path.Combine(_environment.ContentRootPath,
                                             "wwwroot/userimages", 
                                             userId.Value.ToString());

                if (!Directory.Exists(directory))
                    Directory.CreateDirectory(directory);

                var fileName = Path.GetRandomFileName();
                var path = Path.Combine(directory, fileName);

                await using FileStream fs = new(path, FileMode.Create);
                await file.OpenReadStream(MaximumFileSize ?? 5120000).CopyToAsync(fs).ConfigureAwait(false);

                images.Add(new SaveImageViewModel(new ImageViewModel(new Domain.Entities.Image($"wwwroot/userimages/{userId.Value}/{fileName}", imageType.Id))));

                imageType = Domain.Constants.ImageType.Secondary;
            }
            catch (Exception ex)
            {
                _logger.LogError("File: {Filename} Error: {Error}", file.Name, ex.Message);
            }               
        }

        Value = images;
        await ValueChanged.InvokeAsync(Value).ConfigureAwait(false);        
    }    
}
